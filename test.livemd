# xxxSola - Elixir

## Elixir - vrednosti, podatki in podatkovne strukture

xxxx podatki vrednosti itd.
spremenljivke

V Elixirju poznamo sledeče osnovne podatkovne tipe:

* števila
  * cela števila (integers)
  * decimalna števila (floats)
* nizi znakov (strings)
* logične vrednosti (booleans)
* atomi (atoms)

V Elixirju poznamo še sledeče podatkovne strukture:

* seznami (lists)
* terke (tuples)
* slovarji (maps)

## Osnovni podatkovni tipi

V Elixirju poznamo sledeče osnovne podatkovne tipe:

* števila
  * cela števila (integers)
  * decimalna števila (floats)
* nizi znakov (strings)
* logične vrednosti (booleans)
* atomi (atoms)

Osnovni podatkovni tipi oziroma osnovne vrste podatkovnih vrednosti

### Cela števila (integers)

Zapis v desetiški obliki:

```elixir
255
```

```elixir
-255
```

Cela števila so lahko zapisana tudi v binarni, oktalni in heksadecimalni obliki:

```elixir
0b0110
```

```elixir
0o644
```

```elixir
0x1F
```

### Decimalna števila

Pri decimalnih številih mara bit pred decimalno vejico zapisana vsaj ena števka:

```elixir
3.14
```

```elixir
# Sicer piride do napaker:
.14
```

### Nizi znakov (strings)

Niz znakov (string) v Elixirju je niz UTF-8 kodiranih znakov zapisanih med dvema dvojnima navednicama:

```elixir
"Hej"
```

```elixir
"ßjziękuję ali čšžČĆ"
```

Nizi znako lahko vsebujejo prelom vrstic ali posebne znake, npr. za prehod v novo vrsto:

```elixir
"foo
bar"
```

```elixir
"foo\nbar"
```

### Logične vrednosti (Booleans)

V Elixir poznamo dve logični vrednosti `resnica` (true) in `neresnica` (false); vse vrednosti so "resnične" (truthy) razen `false` in `nil`:

```elixir
true
```

```elixir
false
```

### Simboli (Atoms)

Simbol (atom) v Elixrju je konstanta čigar ime je hkrati njegova vrednost.

```elixir
:foo == :bar
```

Imena modulov v Elixirju so simboli / atomi. `MyApp.MyModule` is veljaven simbol / atom.

```elixir
is_atom(MyApp.MyModule)
```

### Osnovne opracije nad osnovnimi tipi podatkov

#### Aritmetika

Elixir podpira osnvne operacije `+`, `-`, `*` (množenje), and `/` (deljenje).
Deljenje zmiraj vrne decimalno število.

```elixir
2 + 2
```

```elixir
2 - 1
```

```elixir
2 * 5
```

```elixir
10 / 5
```

Za celoštevilno deljenje ali ostanek deljenja (modulo) uporabimo funkciji 'div' in 'rem':

```elixir
div(10, 5)
```

```elixir
rem(10, 3)
```

#### Logične operacije


Tri osnovne logične operacije so 'in' (and), 'ali' (or) ter 'ne' (not).
 (`true` or `false`):

```elixir
true and 42
```

```elixir
false or true
```

```elixir
not false
```

```elixir
42 and true
```

```elixir
not 42
```


Elixir omogoča logične operacije `||` (ali), `&&` (in) ter `!` (negacija).
These support any types:

```elixir
20 || true
```

```elixir
false || 42
```

```elixir
42 && true
```

```elixir
42 && nil
```

```elixir
!42
```

```elixir
!false
```


#### Primerjalni

V Elixirju imamo vse običanje primerjalne operatorje: `= =`, `!=`, `= = =`, `!= =`, `<=`, `>=`, `<` in `>`.


`= = (enako)`

```elixir
2 = = 2
```

`!= (Ni enako)`

```elixir
1 != 2
```

`> (večje od)`

```elixir
1 > 2
```

`<(manj kot)`

```elixir
1 < 2
```

`>= (večji ali enak)`

```elixir
2 >= 3
```

```elixir
3 >= 3
```

`<= (manj ali enako)`

```elixir
2 <= 3
```

```elixir
3 >= 3
```

Za strogo primirjanje celih in decimalnih števil se uporabi `= = =` in `!= =`:

```elixir
2 === 2.0
```


#### Interpolacija nizov znakov

Za tvorjenje nizov znakov lahko uporabimo interpolacijo `"Hello #{name}"`:

```elixir
name = "Pinko"
"Hello #{name}"
```

#### Združevanje nizov znakov

Za združevanje nizov znakov se uporablja `<>` operator:

```elixir
name = "Pinko"
"Hello " <> name
```

## Podatkovne strukture


V Elixirju poznamo še sledeče podatkovne strukture:

* seznami (lists)
* terke (tuples)
* slovarji (maps)

## Seznami (Lists)

Lists are simple collections of values which may include multiple types; lists may also include non-unique values:

```elixir
list = [3.14, :pie, "Apple"]
```

Elixir implements list collections as linked lists.
This means that accessing the list length is an operation that will run in linear time (`O(n)`).
For this reason, it is typically faster to prepend than to append:

```elixir
# Prepending (fast)
["π" | list]
```

```elixir
# Appending (slow)
list ++ ["Cherry"]
```

### List Concatenation

List concatenation uses the `++/2` operator:

```elixir
[1, 2] ++ [3, 4, 1]
```

A side note about the name (`++/2`) format used above:
In Elixir (and Erlang, upon which Elixir is built), a function or operator name has two components: the name you give it (here `++`) and its *arity*.
Arity is a core part of speaking about Elixir (and Erlang) code.
It is the number of arguments a given function takes (two, in this case).
Arity and the given name are combined with a slash. We'll talk more about this later; this knowledge will help you understand the notation for now.

#### List Subtraction

Support for subtraction is provided via the `--/2` operator; it's safe to subtract a missing value:

```elixir
["foo", :bar, 42] -- [42, "bar"]
```

Be mindful of duplicate values.
For every element on the right, the first occurrence of it gets removed from the left:

```elixir
[1, 2, 2, 3, 2, 3] -- [1, 2, 3, 2]
```

**Note:** List subtraction uses [strict comparison](../basics/#comparison) to match the values. For example:

```elixir
[2] -- [2.0]
```

```elixir
[2.0] -- [2.0]
```

#### Head / Tail

When using lists, it is common to work with a list's head and tail.
The head is the list's first element, while the tail is a list containing the remaining elements.
Elixir provides two helpful functions, `hd` and `tl`, for working with these parts:

```elixir
hd([3.14, :pie, "Apple"])
```

```elixir
tl([3.14, :pie, "Apple"])
```

In addition to the aforementioned functions, you can use [pattern matching](../pattern-matching/) and the cons operator `|` to split a list into head and tail. We'll learn more about this pattern in later lessons:

```elixir
[head | tail] = [3.14, :pie, "Apple"]
```

```elixir
head
```

```elixir
tail
```

## Terke (Tuples)

Terke so urejene n-terke in so nespremenljive.

Terke se zapisujeo z zavitimi oklepaji ter elemnti razdvojenimi z vejico:

```elixir
{640, 480"}
```

```elixir
{:ok, "abc 123"}
```


```elixir
{3.14, :pie, "Apple"}
```

Pogosto se uporabljajo kot podatkovna struktura za vračilo informacij iz funkcije. 
  
```elixir
File.read("/root/livebook/notebook/elixir-school/basics.livemd")
```

```elixir
File.read("path/to/unknown/file")
```

## Slovarji (Maps)


Slovarji so neurejena, asociativna podatkovna struktura katere elementi so par ključ in vrednost.
- "barva sonca" --> "rumena"

Slovarji so v Elixirju temaljna shramba tipa ključ-vrednost: "ime" - "Toni", "naslov" - "Ulica 1".

Slovarji so optimizirani za pridobivanje vrednosti, ko je ključ znan.


Slovar zapišemo kot `%{ključ1 => vrednost1, ključ2 => vrednost2}`. 

```elixir
slovar = %{:ime => "Pinko", "priimek" => "Palino", :naslov => "Koper"}
```

Do posameznih elementov v slovarju dostopamo z `slovar[ključ]`

```elixir
slovar[:ime]
```

```elixir
slovar["priimek"]
```

Ker v slovarjih pogosto za ključe uporabljamo atome obstaja krajši zapis:

```elixir
%{foo: "bar", hello: "world"}
```

```elixir
%{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
```

Krajšnica za dostop do elementov slovarja, če uporabljamo atome za ključe:

```elixir
map = %{foo: "bar", hello: "world"}
map.hello
```



## Enum

### Enum

The `Enum` module includes over 70 functions for working with enumerables.
All the collections that we learned about in the [previous lesson](../collections/), with the exception of tuples, are enumerables.

This lesson will only cover a subset of the available functions, however we can actually examine them ourselves.
Let's do a little experiment in IEx.

```elixir
Enum.__info__(:functions)
|> Enum.each(fn {function, arity} ->
  IO.puts("#{function}/#{arity}")
end)
```

Using this, it's clear that we have a vast amount of functionality, and that is for a clear reason.
Enumeration is at the core of functional programming, and combined with other perks of Elixir it can be incredibly empowering for developers.

For a full list of functions visit the official [`Enum`](https://hexdocs.pm/elixir/Enum.html) docs; for lazy enumeration use the [`Stream`](https://hexdocs.pm/elixir/Stream.html) module.

#### all?

When using `all?/2`, and much of `Enum`, we supply a function to apply to our collection's items.
In the case of `all?/2`, the entire collection must evaluate to `true` otherwise `false` will be returned:

```elixir
Enum.all?(["foo", "bar", "hello"], fn s -> String.length(s) == 3 end)
```

```elixir
Enum.all?(["foo", "bar", "hello"], fn s -> String.length(s) > 1 end)
```

#### any?

Unlike the above, `any?/2` will return `true` if at least one item evaluates to `true`:

```elixir
Enum.any?(["foo", "bar", "hello"], fn s -> String.length(s) == 5 end)
```

#### chunk_every

If you need to break your collection up into smaller groups, `chunk_every/2` is the function you're probably looking for:

```elixir
Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
```

There are a few options for `chunk_every/4` but we won't go into them, check out [`the official documentation of this function`](https://hexdocs.pm/elixir/Enum.html#chunk_every/4) to learn more.

#### chunk_by

If we need to group our collection based on something other than size, we can use the `chunk_by/2` function.
It takes a given enumerable and a function, and when the return on that function changes a new group is started and begins the creation of the next:

```elixir
Enum.chunk_by(["one", "two", "three", "four", "five"], fn x -> String.length(x) end)
```

```elixir
Enum.chunk_by(["one", "two", "three", "four", "five", "six"], fn x -> String.length(x) end)
```

#### map_every

Sometimes chunking out a collection isn't enough for exactly what we may need.
If this is the case, `map_every/3` can be very useful to hit every `nth` items, always hitting the first one:

```elixir
# Apply function every three items
Enum.map_every([1, 2, 3, 4, 5, 6, 7, 8], 3, fn x -> x + 1000 end)
```

#### each

It may be necessary to iterate over a collection without producing a new value, for this case we use `each/2`:

```elixir
Enum.each(["one", "two", "three"], fn s -> IO.puts(s) end)
```

**Note**: The `each/2` function does return the atom `:ok`.

#### map

To apply our function to each item and produce a new collection look to the `map/2` function:

```elixir
Enum.map([0, 1, 2, 3], fn x -> x - 1 end)
```

#### min

`min/1` finds the minimal value in the collection:

```elixir
Enum.min([5, 3, 0, -1])
```

`min/2` does the same, but in case the enumerable is empty, it allows us to specify a function to produce the minimum value.

```elixir
Enum.min([], fn -> :foo end)
```

#### max

`max/1` returns the maximal value in the collection:

```elixir
Enum.max([5, 3, 0, -1])
```

`max/2` is to `max/1` what `min/2` is to `min/1`:

```elixir
Enum.max([], fn -> :bar end)
```

#### filter

The `filter/2` function enables us to filter the collection to include only those elements that evaluate to `true` using the provided function.

```elixir
Enum.filter([1, 2, 3, 4], fn x -> rem(x, 2) == 0 end)
```

#### reduce

With `reduce/3` we can distill our collection down into a single value.
To do this we supply an optional accumulator (`10` in this example) to be passed into our function; if no accumulator is provided the first element in the enumerable is used:

```elixir
Enum.reduce([1, 2, 3], 10, fn x, acc -> x + acc end)
```

```elixir
Enum.reduce([1, 2, 3], fn x, acc -> x + acc end)
```

```elixir
Enum.reduce(["a", "b", "c"], "1", fn x, acc -> x <> acc end)
```

#### sort

Sorting our collections is made easy with not one, but two, sorting functions.

`sort/1` uses Erlang's [term ordering](http://erlang.org/doc/reference_manual/expressions.html#term-comparisons) to determine the sorted order:

```elixir
Enum.sort([5, 6, 1, 3, -1, 4])
```

```elixir
Enum.sort([:foo, "bar", Enum, -1, 4])
```

While `sort/2` allows us to provide a sorting function of our own:

```elixir
# with our function
Enum.sort([%{:val => 4}, %{:val => 1}], fn x, y -> x[:val] > y[:val] end)
```

```elixir
# without
Enum.sort([%{:count => 4}, %{:count => 1}])
```

For convenience, `sort/2` allows us to pass `:asc` or `:desc` as the sorting function:

```elixir
Enum.sort([2, 3, 1], :desc)
```

#### uniq

We can use `uniq/1` to remove duplicates from our enumerables:

```elixir
Enum.uniq([1, 2, 3, 2, 1, 1, 1, 1, 1])
```

#### uniq_by

`uniq_by/2` also removes duplicates from enumerables, but it allows us to provide a function to do the uniqueness comparison.

```elixir
Enum.uniq_by([%{x: 1, y: 1}, %{x: 2, y: 1}, %{x: 3, y: 3}], fn coord -> coord.y end)
```

#### Enum using the Capture operator (&)

Many functions within the Enum module in Elixir take anonymous functions as an argument to work with each iterable of the enumerable that is passed.

These anonymous functions are often written shorthand using the Capture operator (&).

Here are some examples that show how the capture operator can be implemented with the Enum module.
Each version is functionally equivalent.

##### Using the capture operator with an anonymous function

Below is a typical example of the standard syntax when passing an anonymous function to `Enum.map/2`.

```elixir
Enum.map([1, 2, 3], fn number -> number + 3 end)
```

Now we implement the capture operator (&); capturing each iterable of the list of numbers ([1,2,3]) and assign each iterable to the variable &1 as it is passed through the mapping function.

```elixir
Enum.map([1, 2, 3], &(&1 + 3))
```

This can be further refactored to assign the prior anonymous function featuring the Capture operator to a variable and called from the `Enum.map/2` function.

```elixir
plus_three = &(&1 + 3)
Enum.map([1, 2, 3], plus_three)
```

##### Using the capture operator with a named function

First we create a named function and call it within the anonymous function defined in `Enum.map/2`.

```elixir
defmodule Adding do
  def plus_three(number), do: number + 3
end

Enum.map([1, 2, 3], fn number -> Adding.plus_three(number) end)
```

Next we can refactor to use the Capture operator.

```elixir
Enum.map([1, 2, 3], &Adding.plus_three(&1))
```

For the most succinct syntax, we can directly call the named function without explicitly capturing the variable.

```elixir
Enum.map([1, 2, 3], &Adding.plus_three/1)
```

## xxxxxxx

###  Ujemanje vzorcev (pattern matching)

Znak enako (=) v Elixirju ni namenjen dodeljebvanju vrednosti temveč *ujemanju vzorcev*. Razumemo ga lahko kot znak enako v matematiki: lava stran enačbe je neka desni strani enačbe.

```elixir
42 = 40 + 2
```

```elixir
42 = 100
```

```elixir
a = 42
```

Pravilo:
- primerjaj tip podatkov
- pripejaj obliko podatkov
- povezave z spremenljivkami (destructuring)

### Pattern matching with lists

iex> those_who_are_assembled = [
...> %{age: "30ish", gender: "Female", name: "Izzy"},
...> %{age: "30ish", gender: "Male", name: "The Author"},
...> %{age: "56", gender: "Male", name: "Roberto"},
...> %{age: "38", gender: "Female", name: "Juliet"},
...> %{age: "21", gender: "Female", name: "Mary"},
...> %{age: "67", gender: "Female", name: "Bobalina"},
...> %{age: "54", gender: "Male", name: "Charlie"},
...> %{age: "10", gender: "Male", name: "Charlie (no relation)"},
...> ]

[first, second, third | others] = those_who_are_assembled


With this code, we're telling Elixir to assign the first, second and third items from the list to the variables first, second and third. We're also telling it to assign the remainder of the list to the others

 pipe symbol (|)

